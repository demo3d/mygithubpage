<!DOCTYPE html>
<html lang="en-us">
  <head>
    <title> Alexander Buzin | Web-development</title>
    <script src="jquery-1.11.1.min.js"></script>
    <script src="three.js"></script>
    <script src="tween.min.js"></script>
    <script src="droid_sans_regular.typeface.js"></script>
    <script src="helvetiker_regular.typeface.js"></script>
    <script src="Wagner.js"></script>
    <script src="Wagner.base.js"></script>
  </head>
  <body>
    <script>
      var scene, camera, render, text, originGeom, textGeom, composer;

      function init() {
        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 1, 1000);
        scene.add(camera);

        textGeom = new THREE.TextGeometry("Alexander Buzin", {

					size: 7,
					height: 3,
					curveSegments: 1,

					font: "helvetiker",
					weight: "normal",
					style: "normal",

					bevelThickness: 2,
					bevelSize: 1.5,
					bevelEnabled: false,

					material: 1,
					extrudeMaterial: 1

                });

        textGeom.computeBoundingBox();
        textGeom.computeVertexNormals();

        var centerX = 0.5 * ( textGeom.boundingBox.max.x - textGeom.boundingBox.min.x );
        var centerY = 0.5 * ( textGeom.boundingBox.max.y - textGeom.boundingBox.min.y );
        var centerZ = 0.5 * ( textGeom.boundingBox.max.z - textGeom.boundingBox.min.z );

        textGeom.dynamic = true;
        textGeom.verticesNeedUpdate = true;

        var scener = new THREE.Object3D();

        var newGeom = new THREE.Object3D();
        var oldGeom = new THREE.Object3D();

        textGeom.faces.forEach( function(face, index) {

            var plusOrMinus1 = Math.random() < 0.5 ? -1 : 1;
            var plusOrMinus2 = Math.random() < 0.5 ? -1 : 1;
            var plusOrMinus3 = Math.random() < 0.5 ? -1 : 1;

            var _diff = 50;

            var xr = Math.random() * _diff * plusOrMinus1;
            var yr = Math.random() * _diff * plusOrMinus2;
            var zr = Math.random() * _diff * plusOrMinus3;

            var triangleback = new THREE.Geometry();

            [].push.apply(triangleback.vertices, [
                    textGeom.vertices[face.a],
                    textGeom.vertices[face.b],
                    textGeom.vertices[face.c]
            ]);

            triangleback.faces.push(new THREE.Face3( 0, 1, 2 ));

            var triangleMeshold = new THREE.Mesh(triangleback, new THREE.MeshBasicMaterial({color: 0x000000}));

            oldGeom.add(triangleMeshold);

            var triangle = new THREE.Geometry();

            [].push.apply(triangle.vertices, [
                    textGeom.vertices[face.a],
                    textGeom.vertices[face.b],
                    textGeom.vertices[face.c]
            ]);

            triangle.faces.push(new THREE.Face3( 0, 1, 2 ));

            triangle.faceVertexUvs[0].push([
                new THREE.Vector2( 0, 0 ),
                new THREE.Vector2( 0, 0.1 ),
                new THREE.Vector2( 0.1, 0.1 ),
                new THREE.Vector2( 0.1, 0 ),
            ]);

            triangle.computeFaceNormals();

            var triangleMesh = new THREE.Mesh(triangle, new THREE.MeshBasicMaterial({map: THREE.ImageUtils.loadTexture('metal2.jpg')}));

            triangleMesh.position.x += xr;
            triangleMesh.position.y += yr;
            triangleMesh.position.z += zr;
            triangleMesh.rotation.x += xr/1000;
            triangleMesh.rotation.y += yr/1000;


            newGeom.add(triangleMesh);

        });




        newGeom.children.forEach(function(vert, index) {
            var tween = new TWEEN.Tween(vert.position).to(oldGeom.children[index].position, 5000)
                .easing( TWEEN.Easing.Cubic.In )
                .onUpdate(function() {
                    vert.position.x = this.x;
                    vert.position.y = this.y;
                    vert.position.z = this.z;
                    vert.rotation.x = this.x/100;
                    vert.rotation.y = this.y/100;
                }).start();

        });

        text = newGeom;

        text.position.set(-centerX, -centerY + 10 ,-50 - centerZ);
        scener.add(text);

        scene.add(scener);

        renderer = new THREE.WebGLRenderer();
        renderer.setClearColor(0xfafafa);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.render(scene, camera);

        $(renderer.domElement).css({
            'width': '100%',
            'height': '100%'
        });

        $(renderer.domElement).attr('');

        $('body').append(renderer.domElement);

        $('body').css({
            'margin': 0,
            'padding': 0,
            'position': 'relative',
            'overflow': 'hidden'
        });


        composer = new WAGNER.Composer( renderer );
        composer.setSize( window.innerWidth, window.innerHeight );
        renderer.autoClearColor = true;
        composer.reset();
        composer.render( scene, camera );


        var wrZB = new WAGNER.ZoomBlurPass();
            wrZB.params.strength = .025;
            wrZB.params.center.set( .5 * composer.width, .5 * composer.height );
          composer.pass( wrZB );

        var wrVP = new WAGNER.VignettePass();
            wrVP.params.amount = 0.7;
            wrVP.params.falloff = 0.2;

        var wrNP = new WAGNER.NoisePass();
            wrNP.params.amount = 0.1;
            wrNP.params.speed = 0.3;

        var wrDP = new WAGNER.DirtPass();


        composer.eff = [];

        composer.eff.push(wrZB);
        composer.eff.push(wrVP);
        composer.eff.push(wrDP);
        composer.eff.push(wrNP);

        animate();

        console.log(TWEEN);
      }

      function animate(time) {


          requestAnimationFrame( animate );

          TWEEN.update(time);

          composer.reset();

          composer.render(scene, camera);

          composer.eff.forEach( function( effect, index) {
             composer.pass( effect );
          })

          composer.toScreen();
            //composer.render(scene, camera);
          //renderer.render(scene, camera);

      }



      $(document).on('mousemove', function(e) {
          var tx = e.clientX - window.innerWidth*0.5;
          var ty = e.clientY - window.innerHeight*0.5;
          //console.log(tx/100);
          camera.position.x = tx/50;
          camera.position.y = ty/50;
          camera.lookAt(new THREE.Vector3(tx/100,ty/100,-50));
      });

    init();
    </script>
  </body>
</html>

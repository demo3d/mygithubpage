<!DOCTYPE html>
<html lang="en-us">
  <head>
    <title> Alexander Buzin | Web-development</title>
    <script src="jquery-1.11.1.min.js"></script>
    <script src="three.js"></script>
    <script src="tween.min.js"></script>
    <script src="droid_sans_regular.typeface.js"></script>
    <script src="helvetiker_regular.typeface.js"></script>
  </head>
  <body>
    <script>
      var scene, camera, render, text, originGeom, textGeom, allgeoms, allgeomsback, allgeomsnow;

      function init() {
        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 1, 1000);
        scene.add(camera);

        textGeom = new THREE.TextGeometry("Alexander Buzin", {

					size: 70,
					height: 30,
					curveSegments: 1,

					font: "helvetiker",
					weight: "normal",
					style: "normal",

					bevelThickness: 2,
					bevelSize: 1.5,
					bevelEnabled: false,

					material: 0,
					extrudeMaterial: 1

                });

        textGeom.computeBoundingBox();
        textGeom.computeVertexNormals();

        textGeom2 = new THREE.TextGeometry("Web-developer", {

					size: 40,
					height: 10,
					curveSegments: 1,

					font: "helvetiker",
					weight: "normal",
					style: "normal",

					bevelThickness: 2,
					bevelSize: 1.5,
					bevelEnabled: false,

					material: 0,
					extrudeMaterial: 1

                });

        textGeom2.computeBoundingBox();
        textGeom2.computeVertexNormals();

        var centerX = 0.5 * ( textGeom.boundingBox.max.x - textGeom.boundingBox.min.x );
        var centerY = 0.5 * ( textGeom.boundingBox.max.y - textGeom.boundingBox.min.y );
        var centerZ = 0.5 * ( textGeom.boundingBox.max.z - textGeom.boundingBox.min.z );

        var centerX2 = ( textGeom2.boundingBox.max.x - textGeom2.boundingBox.min.x );
        var centerY2 = ( textGeom2.boundingBox.max.y - textGeom2.boundingBox.min.y );
        var centerZ2 = 0.5 * ( textGeom2.boundingBox.max.z - textGeom2.boundingBox.min.z );

        textGeom.dynamic = true;
        textGeom.verticesNeedUpdate = true;
        textGeom2.dynamic = true;
        textGeom2.verticesNeedUpdate = true;

        var scener = new THREE.Object3D();

        var newGeom = new THREE.Object3D();
        var oldGeom = new THREE.Object3D();

        textGeom.faces.forEach( function(face, index) {

            var plusOrMinus1 = Math.random() < 0.5 ? -1 : 1;
            var plusOrMinus2 = Math.random() < 0.5 ? -1 : 1;
            var plusOrMinus3 = Math.random() < 0.5 ? -1 : 1;

            var _diff = 500;

            var xr = Math.random() * _diff * plusOrMinus1;
            var yr = Math.random() * _diff * plusOrMinus2;
            var zr = Math.random() * _diff * plusOrMinus3;

            var triangleback = new THREE.Geometry();

            [].push.apply(triangleback.vertices, [
                    textGeom.vertices[face.a],
                    textGeom.vertices[face.b],
                    textGeom.vertices[face.c]
            ]);

            triangleback.faces.push(new THREE.Face3( 0, 1, 2 ));

            var triangleMeshold = new THREE.Mesh(triangleback, new THREE.MeshBasicMaterial({color: 0x000000}));

            oldGeom.add(triangleMeshold);

            var triangle = new THREE.Geometry();

            [].push.apply(triangle.vertices, [
                    textGeom.vertices[face.a],
                    textGeom.vertices[face.b],
                    textGeom.vertices[face.c]
            ]);

            triangle.faces.push(new THREE.Face3( 0, 1, 2 ));

            triangle.computeFaceNormals();

            var triangleMesh = new THREE.Mesh(triangle, new THREE.MeshBasicMaterial({color: 0x000000}));

            triangleMesh.position.x += xr;
            triangleMesh.position.y += yr;
            triangleMesh.position.z += zr;
            triangleMesh.rotation.x += xr/1000;
            triangleMesh.rotation.y += yr/1000;


            newGeom.add(triangleMesh);

        });


        var newGeom2 = new THREE.Object3D();
        var oldGeom2 = new THREE.Object3D();

        textGeom2.faces.forEach( function(face, index) {

            var plusOrMinus1 = Math.random() < 0.5 ? -1 : 1;
            var plusOrMinus2 = Math.random() < 0.5 ? -1 : 1;
            var plusOrMinus3 = Math.random() < 0.5 ? -1 : 1;

            var _diff = 500;

            var xr = Math.random() * _diff * plusOrMinus1;
            var yr = Math.random() * _diff * plusOrMinus2;
            var zr = Math.random() * _diff * plusOrMinus3;

            var triangleback = new THREE.Geometry();

            [].push.apply(triangleback.vertices, [
                    textGeom2.vertices[face.a],
                    textGeom2.vertices[face.b],
                    textGeom2.vertices[face.c]
            ]);

            triangleback.faces.push(new THREE.Face3( 0, 1, 2 ));

            var triangleMeshold = new THREE.Mesh(triangleback, new THREE.MeshBasicMaterial({color: 0x0000ff}));

            oldGeom2.add(triangleMeshold);

            var triangle = new THREE.Geometry();

            [].push.apply(triangle.vertices, [
                    textGeom2.vertices[face.a],
                    textGeom2.vertices[face.b],
                    textGeom2.vertices[face.c]
            ]);

            triangle.faces.push(new THREE.Face3( 0, 1, 2 ));

            triangle.computeFaceNormals();

            var triangleMesh = new THREE.Mesh(triangle, new THREE.MeshBasicMaterial({color: 0x0000ff}));

            triangleMesh.position.x += xr;
            triangleMesh.position.y += yr;
            triangleMesh.position.z += zr;
            triangleMesh.rotation.x += xr/1000;
            triangleMesh.rotation.y += yr/1000;


            newGeom2.add(triangleMesh);

        });




        newGeom.children.forEach(function(vert, index) {
            var tween = new TWEEN.Tween(vert.position).to(oldGeom.children[index].position, 3000)
                .easing( TWEEN.Easing.Cubic.In )
                .onUpdate(function() {
                    vert.position.x = this.x;
                    vert.position.y = this.y;
                    vert.position.z = this.z;
                    vert.rotation.x = this.x/1000;
                    vert.rotation.y = this.y/1000;
                }).start();

        });

        newGeom2.children.forEach(function(vert, index) {
            var tween = new TWEEN.Tween(vert.position).to(oldGeom2.children[index].position, 3000)
                .easing( TWEEN.Easing.Cubic.In )
                .onUpdate(function() {
                    vert.position.x = this.x;
                    vert.position.y = this.y;
                    vert.position.z = this.z;
                    vert.rotation.x = this.x/1000;
                    vert.rotation.y = this.y/1000;
                }).start();

        });

        /*var tween2 = new TWEEN.Tween({x: +Math.PI/90*180}).to({x: 0}, 3000)
                .easing( TWEEN.Easing.Cubic.In )
                .onUpdate(function() {
                    scener.rotation.y = this.x;
                }).start();*/

        //textGeom.vertices = vrts;
        //originGeom.vertices = ovrts;
        //textGeom.faces = fcs;

        text = newGeom;

        text.position.set(-centerX, -centerY + 100 ,-500 - centerZ);
        scener.add(text);


        newGeom2.position.set(0, -100 ,-500 - centerZ);
        scener.add(newGeom2);

        scene.add(scener);

        renderer = new THREE.WebGLRenderer();
        renderer.setClearColor(0xfafafa);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.render(scene, camera);

        $(renderer.domElement).css({
            'width': '100%',
            'height': '100%'
        });

        $(renderer.domElement).attr('');

        $('body').append(renderer.domElement);

        $('body').css({
            'margin': 0,
            'padding': 0,
            'position': 'relative',
            'overflow': 'hidden'
        });

        animate();

        console.log(TWEEN);
      }

      function animate(time) {




          renderer.render(scene, camera);

          requestAnimationFrame( animate );

          TWEEN.update(time);

      }

    init();
    </script>
  </body>
</html>
